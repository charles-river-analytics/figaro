/*
 * ReferenceElement.scala
 * Elements representing references and aggregates over references.
 * 
 * Created By:      Avi Pfeffer (apfeffer@cra.com)
 * Creation Date:   Jan 1, 2009
 * 
 * Copyright 2013 Avrom J. Pfeffer and Charles River Analytics, Inc.
 * See http://www.cra.com or email figaro@cra.com for information.
 * 
 * See http://www.github.com/p2t2/figaro for a copy of the software license.
 */

package com.cra.figaro.language

import com.cra.figaro.algorithm._
import com.cra.figaro.algorithm.factored._
import com.cra.figaro.util._
import scala.language.existentials

/**
 * Element representing the value of a reference.
 * 
 * @param collection The collection to use to resolve the reference.
 * @param reference The reference whose value is represented by this element.
 * 
 */
abstract class ReferenceElement[T, U](collection: ElementCollection, val reference: Reference[T])
  extends Deterministic[U]("", collection) with IfArgsCacheable[U] {
  lazy val args = collection.makeArgs(reference).toList
}

/**
 * Element representing a single-valued reference. Its value in a state is generated by following the reference
 * in the state and taking the value of the resulting element.
 */
class SingleValuedReferenceElement[T](collection: ElementCollection, reference: Reference[T])
  extends ReferenceElement[T, T](collection, reference) with ValuesMaker[T] with ProbFactorMaker {
  def generateValue() = collection.getElementByReference(reference).value

  def makeValues: Set[T] = collection.referenceValues(reference)

  def makeFactors: List[Factor[Double]] = {
    val (first, rest) = collection.getFirst(reference)
    rest match {
      case None =>
        val thisVar = Variable(this)
        val refVar = Variable(first)
        val factor = new Factor[Double](List(thisVar, refVar))
        for {
          i <- 0 until refVar.range.size
          j <- 0 until refVar.range.size
        } {
          factor.set(List(i, j), (if (i == j) 1.0; else 0.0))
        }
        List(factor)
      case Some(restRef) =>
        val firstVar = Variable(first)
        val selectedFactors =
          for {
            (firstValue, firstIndex) <- firstVar.range.zipWithIndex
            firstCollection = firstValue.asInstanceOf[ElementCollection]
            restElement = new SingleValuedReferenceElement(firstCollection, restRef)
          } yield {
            ProbFactor.makeConditionalSelector(this, firstVar, firstIndex, restElement) :: restElement.makeFactors
          }
        selectedFactors.flatten
    }
  }
}

/**
 * Aggregate elements based on multi-valued references. Note that the values aggregated over are all the values of
 * all elements that are referred to by the reference. If the same element is reachable by more than one path in the
 * reference, its value is only included once. However, if two different referred to elements have the same value,
 * the value is included multiple times. Since the order of these values is immaterial, we use a multiset to represent them.
 * 
 * @param aggregate A function to aggregate elements referred to by the reference into a value of this aggregate element.
 */
class Aggregate[T, U](collection: ElementCollection, reference: Reference[T], aggregate: MultiSet[T] => U)
  extends ReferenceElement[T, U](collection, reference) with ValuesMaker[U] with ProbFactorMaker {

  private case class MultiValuedReferenceElement[T](coll: ElementCollection, ref: Reference[T]) extends ReferenceElement[T, MultiSet[T]](coll, ref)
    with ValuesMaker[MultiSet[T]] with ProbFactorMaker {

    override val hashCode = ref.hashCode()
    override def equals(that: Any): Boolean = {
      try {
        val ms = that.asInstanceOf[MultiValuedReferenceElement[T]]
        coll == ms.coll && ref == ms.ref
      } catch {
        case _: ClassCastException => false
      }
    }

    // collection.getElements is a set of elements, because if the same element is reachable by more than one path, it is only counted once. 
    // We convert it to a list so we get all the values of these elements, even if some of the elements have the same values. 
    def generateValue(): MultiSet[T] = HashMultiSet(collection.getManyElementsByReference(reference).toList: _*) map ((e: Element[T]) => e.value)

    private def allUnions(setset1: Set[MultiSet[T]], setset2: Set[MultiSet[T]]): Set[MultiSet[T]] = {
      for { set1 <- setset1; set2 <- setset2 } yield set1 union set2
    }

    def makeValues: Set[MultiSet[T]] = {
      val (first, rest) = collection.getFirst(reference)
      rest match {
        case None => Values()(first.asInstanceOf[Element[T]]).map((t: T) => HashMultiSet(List(t): _*))
        case Some(restRef) =>
          val results: Set[Set[MultiSet[T]]] =
            for { firstValue <- Values()(first) } yield {
              firstValue match {
                case firstColl: ElementCollection => Values()(MultiValuedReferenceElement(firstColl, restRef))
                case ecs: Traversable[_] =>
                  val resultSets: Traversable[Set[MultiSet[T]]] =
                    for {
                      ec <- ecs.toList.distinct // Aggregates use set semantics for the elements they use. If the same element appears more than once, it is only counted once.
                      firstColl = ec.asInstanceOf[ElementCollection]
                      restMulti = MultiValuedReferenceElement(firstColl, restRef)
                    } yield { Values()(restMulti) }
                  val starter: Set[MultiSet[T]] = Set(HashMultiSet[T]())
                  (starter /: resultSets)(allUnions(_, _))
              }
            }
          results.flatten
      }
    }

    def makeFactors: List[Factor[Double]] = {
      val (first, rest) = collection.getFirst(reference)
      val selectionFactors: List[List[Factor[Double]]] = {
        rest match {
          case None =>
            val thisVar = Variable(this)
            val refVar = Variable(first)
            val factor = new Factor[Double](List(thisVar, refVar))
            for {
              i <- 0 until refVar.range.size
              j <- 0 until refVar.range.size
            } {
              factor.set(List(i, j), (if (i == j) 1.0; else 0.0))
            }
            List(List(factor))
          case Some(restRef) =>
            val firstVar = Variable(first)
            for {
              (firstValue, firstIndex) <- firstVar.range.zipWithIndex
            } yield {
              firstValue match {
                case firstCollection: ElementCollection =>
                  val restElement = new MultiValuedReferenceElement[T](firstCollection, restRef)
                  val result: List[Factor[Double]] =
                    ProbFactor.makeConditionalSelector(this, firstVar, firstIndex, restElement) :: ProbFactor.make(restElement)
                  result
                case cs: Traversable[_] =>
                  // Create a multi-valued reference element (MVRE) for each collection in the value of the first name.
                  // Since the first name is multi-valued, its value is the union of the values of all these MVREs.
                  val collections = cs.asInstanceOf[Traversable[ElementCollection]].toList.distinct // Set semantics
                  val multis: List[MultiValuedReferenceElement[T]] = collections.map(MultiValuedReferenceElement(_, restRef)).toList
                  // Create the element that takes the union of the values of the all the MVREs.
                  val combination: Element[List[MultiSet[T]]] = Inject(multis: _*)
                  val starter: MultiSet[T] = HashMultiSet[T]()
                  val setMaker = Apply(combination, (sets: List[MultiSet[T]]) => (starter /: sets)(_ union _))
                  // The combination and setMaker elements are encapsulated within this object and are created now, so we need to create factors for them. 
                  // Finally, we create a conditional selector (see ProbFactor) to select the appropriate result value when the first
                  // name's value is these MVREs.
                  val result: List[Factor[Double]] =
                    ProbFactor.makeConditionalSelector(this, firstVar, firstIndex, setMaker) :: ProbFactor.make(combination) :::
                      ProbFactor.make(setMaker)
                  result
              }
            }
        }
      }
      selectionFactors.flatten
    }
  }

  private def possibleInputs: Set[MultiSet[T]] = Values()(MultiValuedReferenceElement(collection, reference))

  def generateValue(): U = aggregate(HashMultiSet(collection.getManyElementsByReference(reference).toList.map(_.value): _*))

  def makeValues: Set[U] = possibleInputs.map(aggregate(_))

  def makeFactors = {
    val mvre = MultiValuedReferenceElement(collection, reference)
    val thisVar = Variable(this)
    val mvreVar = Variable(mvre)
    val factor = new Factor[Double](List(thisVar, mvreVar))
    for {
      (thisValue, thisIndex) <- thisVar.range.zipWithIndex
      (mvreValue, mvreIndex) <- mvreVar.range.zipWithIndex
    } {
      factor.set(List(thisIndex, mvreIndex), if (aggregate(mvreValue) == thisValue) 1.0; else 0.0)
    }
    // The MultiValuedReferenceElement for this aggregate is generated when Values() is called. 
    // Therefore, it will be included in the expansion and have factors made for it automatically, so we do not create factors for it here.
    List(factor)
  }
}
